<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Family Tree ¬∑ Family Tree PWA</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/main.css" />
  <style>
  #treeCanvas { width: 100%; min-height: 40vh; border-radius: 12px; background:#fff; box-shadow: 0 8px 28px rgba(0,0,0,0.06); padding: 14px; color:#222; }
  ul { color:#222; }
  .node { display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:8px; color:#1a1a1a; font-size:14px; line-height:1.35; }
  .node:hover { background:#eef3ff; }
  .expander { width: 20px; text-align:center; cursor:pointer; user-select:none; color:#2c3e50; font-weight:700; font-size:14px; }
  .expander.hidden { visibility:hidden; }
  .children { margin-left: 24px; border-left: 1px dashed #cfd7e6; padding-left: 12px; }
  .label { cursor:pointer; color:#0f172a; font-weight:600; }
  .muted { color:#64748b; font-weight:500; }

  /* Mobile-friendly tweaks for the tree view */
  @media (max-width: 700px) {
    #treeCanvas {
      padding: 12px;
      min-height: 50vh;
      overflow-x: auto;
      overflow-y: visible;
      -webkit-overflow-scrolling: touch;
      scrollbar-gutter: stable both-edges;
    }
    .node {
      gap: 10px;
      padding: 8px 10px;
      font-size: 15px;
      line-height: 1.4;
    }
    .expander { width: 28px; font-size: 16px; touch-action: manipulation; }
    .children { margin-left: 16px; padding-left: 10px; border-left-color:#e2e8f0; }
    .label { overflow-wrap: anywhere; }
  }

  @media (max-width: 420px) {
    .node { font-size: 15px; padding: 9px 10px; }
    .expander { width: 32px; font-size: 18px; }
    .children { margin-left: 12px; padding-left: 8px; }
  }

  /* Accessibility/focus */
  .expander:focus-visible, .label:focus-visible { outline:2px solid #3b82f6; outline-offset:2px; border-radius:6px; }
  </style>
</head>
<body>
  <main class="hero">
    <div class="glass card-enter" style="max-width:1100px;">
      <header class="wizard-head">
        <div style="display:flex; align-items:center; gap:12px; justify-content:space-between;">
          <div class="tagline">Signed in as: <strong id="sessionEmail">...</strong></div>
          <nav style="display:flex; gap:10px;">
            <a class="link" href="/pages/EN/dashboard.html">‚Ü©Ô∏è</a>
            <a class="link" href="/pages/EN/auth/logout.php">‚ùå</a>
          </nav>
        </div>
        <h1>Your Family Treeüå≤</h1>
        <p class="tagline">üå≤This is a placeholder page for the interactive tree.</p>
      </header>

      <section>
        <div style="margin-bottom:10px; display:flex; gap:8px; align-items:center;">
          <label class="tagline" for="parentSelect">Start from parents:</label>
          <select id="parentSelect" class="input" style="min-width:260px;"></select>
        </div>
        <div id="treeCanvas"></div>
        <div class="actions" style="margin-top:16px; display:flex; gap:10px;">
          <a class="btn btn-ghost" href="/pages/EN/dashboard.html">Back to dashboard</a>
          
        </div>
      </section>
    </div>
    <footer>
    <p><small>¬© 2025 Nasab Family Tree ‚Äì Experimental Beta Release. Developed by a personal developer for educational purposes only.</small></p>
  </footer>
  </main>
  <script>
  fetch('/api/session_info.php').then(r => r.ok ? r.json() : { ok:false }).then(u=>{
      const el=document.getElementById('sessionEmail'); if (el) el.textContent = (u&&u.ok&&u.user&&u.user.email)||'‚Äî';
    }).catch(()=>{});
    window.addEventListener('load',()=>{
      document.querySelector('.card-enter')?.classList.add('in');
      loadTree();
    });

    async function loadTree(){
      try {
  const res = await fetch('/api/family_tree.php');
        const j = await res.json();
        if (!j || !j.ok) { renderError('Unable to load family tree'); return; }
        renderTree(j);
      } catch(_){ renderError('Unable to load family tree'); }
    }

    function renderError(msg){
      const root = document.getElementById('treeCanvas');
      root.innerHTML = `<div class="tagline" style="color:#b33;">${msg}</div>`;
    }

    function renderTree(data){
      const root = document.getElementById('treeCanvas');
      root.innerHTML = '';
      const { people, roots, parent_pairs, couples } = data;
      if (!people || Object.keys(people).length === 0){
        root.innerHTML = '<div class="tagline">No family members yet.</div>';
        return;
      }
      // Populate parent selector with known couples (parent pairs with b>0)
      const sel = document.getElementById('parentSelect');
      sel.innerHTML = '';
      const mkLabel = (pid)=> people[pid] ? people[pid].name : `#${pid}`;
      const couplesList = (couples && couples.length) ? couples : [];
      if (couplesList.length === 0){
        const opt = document.createElement('option'); opt.value = ''; opt.textContent = 'No parent couples found'; sel.appendChild(opt);
        // Fallback: show individuals roots
        const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.padding='0'; ul.style.margin='0';
        roots.forEach(rid => { ul.appendChild(renderSubtree(rid, people)); });
        root.appendChild(ul);
        return;
      }
      couplesList.forEach(c=>{
        const opt = document.createElement('option');
        opt.value = c.key;
        opt.textContent = `${mkLabel(c.a)} + ${mkLabel(c.b)}`;
        sel.appendChild(opt);
      });
      sel.addEventListener('change', ()=>renderFromCouple(data, sel.value));
      renderFromCouple(data, sel.value || couplesList[0].key);
    }

    function renderFromCouple(data, key){
      const root = document.getElementById('treeCanvas');
      root.innerHTML = '';
      const { people, parent_pairs } = data;
      if (!key || !parent_pairs[key]){ root.innerHTML = '<div class="tagline">No data for selected parents.</div>'; return; }
      const pair = parent_pairs[key];
      const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.padding='0'; ul.style.margin='0';
      ul.appendChild(renderCouple(pair.a, pair.b, data));
      root.appendChild(ul);
    }

    // Render a couple and their descendants in Couple ‚Üí (Child + Spouse) blocks
    function renderCouple(aId, bId, data){
      const { people, parent_pairs } = data;
      const li = document.createElement('li');
      const row = document.createElement('div'); row.className='node';
      const exp = document.createElement('span'); exp.className='expander'; exp.textContent='‚ñæ';
      row.appendChild(exp);
      // Render both parents as individually clickable labels
      const a = people[aId];
      const b = people[bId];
      const aLbl = document.createElement('span'); aLbl.className='label'; aLbl.textContent = a ? a.name : ('#'+aId);
      if (a) aLbl.addEventListener('click', ()=> onNodeClick(a));
      const plus = document.createElement('span'); plus.textContent = ' + ';
      const bLbl = document.createElement('span'); bLbl.className='label'; bLbl.textContent = b ? b.name : ('#'+bId);
      if (b) bLbl.addEventListener('click', ()=> onNodeClick(b));
      row.appendChild(aLbl); row.appendChild(plus); row.appendChild(bLbl);
      li.appendChild(row);

      let open = true;
      const kidsWrap = document.createElement('div'); kidsWrap.className='children'; kidsWrap.style.display = '';
      const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.padding='0'; ul.style.margin='0';

      const key = `${Math.min(aId,bId)}-${Math.max(aId,bId)}`;
      const children = sortChildren((parent_pairs[key]?.children)||[], data.people);
      children.forEach(cid => {
        ul.appendChild(renderChildGroups(cid, data));
      });
      kidsWrap.appendChild(ul); li.appendChild(kidsWrap);

      exp.addEventListener('click', ()=>{ open=!open; exp.textContent = open?'‚ñæ':'‚ñ∏'; kidsWrap.style.display = open?'':'none'; });
      return li;
    }

    // Render a child grouped by each co-parent (partner with whom they have children).
    // For each group, we show: Child + CoParent, then their children beneath.
    function renderChildGroups(childId, data){
      const { people, co_parents, parent_pairs } = data;
      const child = people[childId];
      const li = document.createElement('li');

      const partners = (co_parents[childId]||[]);
      if (!partners.length){
        // simple leaf node with just the child
        const row = document.createElement('div'); row.className='node';
        const exp = document.createElement('span'); exp.className='expander hidden'; row.appendChild(exp);
        const cLbl = document.createElement('span'); cLbl.className='label'; cLbl.textContent = child.name; cLbl.addEventListener('click', ()=> onNodeClick(child));
        row.appendChild(cLbl);
        li.appendChild(row);
        return li;
      }

      // When multiple partner families exist, render each couple block, one under another
      const wrap = document.createElement('div'); wrap.className='children'; wrap.style.borderLeft='none';
      const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.padding='0'; ul.style.margin='0';

      partners.forEach(pid => {
        ul.appendChild(renderCouple(childId, pid, data));
      });

      wrap.appendChild(ul); li.appendChild(wrap);
      return li;
    }
    function renderSubtree(pid, people){
      const li = document.createElement('li');
      const p = people[pid]; if (!p) return li;

      const hasKids = (p.children && p.children.length > 0);
      const row = document.createElement('div'); row.className = 'node';
      const exp = document.createElement('span');
      exp.className = 'expander' + (hasKids ? '' : ' hidden');
      exp.textContent = hasKids ? '‚ñ∏' : '';
      row.appendChild(exp);

  const label = document.createElement('span'); label.className='label'; label.innerHTML = formatPerson(p);
      label.addEventListener('click', ()=> onNodeClick(p));
      row.appendChild(label);
      li.appendChild(row);

      let open = false;
      let kidsContainer = null;
      if (hasKids){
        kidsContainer = document.createElement('div');
        kidsContainer.className = 'children';
        kidsContainer.style.display = 'none';
        const ul = document.createElement('ul'); ul.style.listStyle='none'; ul.style.padding='0'; ul.style.margin='0';
        p.children.forEach(cid => { ul.appendChild(renderSubtree(cid, people)); });
        kidsContainer.appendChild(ul);
        li.appendChild(kidsContainer);
        exp.addEventListener('click', ()=>{
          open = !open; exp.textContent = open ? '‚ñæ' : '‚ñ∏';
          kidsContainer.style.display = open ? '' : 'none';
        });
      }
      return li;
    }

    function formatPerson(p){
      const parts = [];
      if (p.birth_date) parts.push(`b. ${p.birth_date}`);
      if (!p.is_alive) parts.push(p.death_date ? `d. ${p.death_date}` : 'deceased');
      const meta = parts.length ? ` <span class="muted">(${parts.join(' ¬∑ ')})</span>` : '';
      return `${escapeHtml(p.name)}${meta}`;
    }

    // Sorting: date (asc), then name
    function parseDateKey(s){
      if (!s) return null;
      // support YYYY or YYYY-MM-DD; take as-is for lexical compare if ISO-like
      const m = String(s).match(/^(\d{4})(?:-(\d{2}))?(?:-(\d{2}))?$/);
      if (m){
        const y = m[1], mo = m[2]||'12', d = m[3]||'31';
        return `${y}-${mo}-${d}`;
      }
      // try numeric year fallback
      const yr = String(s).match(/^(\d{4})$/); if (yr) return `${yr[1]}-12-31`;
      return null;
    }
    function compareIdsByBirthThenName(aId, bId, people){
      const a = people[aId]||{}; const b = people[bId]||{};
      const ak = parseDateKey(a.birth_date); const bk = parseDateKey(b.birth_date);
      if (ak && bk){ if (ak < bk) return -1; if (ak > bk) return 1; }
      else if (ak && !bk) return -1; else if (!ak && bk) return 1;
      const an = (a.name||'').toLowerCase(); const bn = (b.name||'').toLowerCase();
      if (an < bn) return -1; if (an > bn) return 1; return 0;
    }
    function sortChildren(arr, people){
      const copy = (arr||[]).slice();
      copy.sort((x,y)=> compareIdsByBirthThenName(x,y,people));
      return copy;
    }

    function escapeHtml(s){
      return String(s||'').replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
    }

    function onNodeClick(person){
      if (!person || !person.id) return;
  window.location.href = `/pages/EN/chat_expand.html?pid=${encodeURIComponent(person.id)}`;
    }
  </script>
</body>
</html>
